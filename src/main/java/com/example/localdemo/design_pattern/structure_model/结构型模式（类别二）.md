# 创建型模式共七种：
## 1.适配器模式：
适配器模式目的是让原本接口 `不兼容的类可以合作无间` 。在适配器模式中，适配器让一个类的接口与另一个类的接口相适应。

### 适配器的实现方法有两种：对象适配器和类适配器。
**对象适配器**：适配器持有原始对象的引用，从而将其自己的接口与原始对象的接口“结合”在一起。
**类适配器**：适配器通过多重继承实现将一个类的接口转换成另一个类所期望的接口形式。


### 2.装饰器模式：
#### 顾名思义，装饰模式就是给一个`对象增加一些新的功能`，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例。
装饰器模式（Decorator Pattern）是一种结构型设计模式，用于动态地向一个对象添加一些额外的行为而不需要修改原来的类。

在该模式中，定义了一个装饰器类和一个组件类，被装饰对象是指该组件类及其子类的实例对象，装饰器类和被装饰对象具有相同的父类，即装饰器类和被装饰对象都是通过实现相同的接口或继承相同的抽象类来实现。

在实现时，装饰器类包含一个被装饰对象的成员变量，并维护一个指向被装饰对象的引用，在装饰器类中调用被装饰对象的方法时，还可以添加一些新的功能。



### 3.代理模式：
-    代理模式指: 为一个对象提供一个替身,以控制对这个对象的访问。既通过代理对象访问目标对象，这样做的好处是: 可以在目标对象实现的基础上，增加额外的功能操作，即扩展目标对象的功能。

- 代理模式分为: 静态代理模式和动态代理模式(JDK 和CGLIB[动态代理是在运行时动态生成的，通过反射动态生成代理类字节码。])。

#### 静态代理的优缺点：
优点:
-    可以在不修改目标对象的前提下,能通过代理对象对目标功能进行扩展。
-    目标对象和代理的扩展功能职责清晰不会产生耦合。

缺点:
-   因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类。
-   一旦接口增加方法，目标对象与代理对象都要维护。

#### CGLIG动态代理/JDK动态代理的优缺点：
优点：
- 如扩展功能类似时，代理工厂类对象是未知的，就可以使用一个代理对象完成扩展功能，使用时指定不同目标对象即可。
- 代理工厂无需实现抽象接口的方法，因为是利用反射在运行时创建的代理对象。

缺点：
- CGlib : 通过继承的方式进行代理,无法处理被final修饰类的情况。
- JDK: 只能基于接口处理。

 ### 4.外观模式：
### 5.桥接模式：
### 6.组合模式：
### 7.享元模式：